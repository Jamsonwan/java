# JVM



## 引言


1、JVM：java程序运行的环境（java二进制字节码的运行环境）
2、优势：
		1）一次编译、到处运行
		2）自动内存管理，垃圾自动回收功能
3、jdk、jvm、jre
	jre = jvm + 基础类库
	jdk = jvm + 基础类库 + 编译工具（javac）
	
4、执行过程：java源代码  ->  jvm指令（二进制字节码）->通过解释器生成机器码
					

## 	内存管理	

1、java虚拟机会把内存分为若干个不同数据区（堆、方法区、虚拟机栈、本地方法栈、程序计数器）
	程序计数器：下一条jvm指令执行的地址（当前线程所执行的字节码的行号指示器）
			1）线程私有
			2）JVM中唯一不会存在内存溢出
	java虚拟机栈：线程运行需要的内存空间（栈帧：每个方法运行时的内存）描述java方法执行的线程内存模型（栈帧用于存储局部变量表，操作数栈、动态链接、方法出口等）
		1）、每个线程运行时所需的内存，称为虚拟机栈
		2）、每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存。
		3）、每个线程只能由一个活动栈帧，对应着当前正在执行的那个方法。
		4）方法内的局部变量是否线程安全：
			···如果方法内局部变量没有逃离方法的作用访问，线程安全；
			···如果局部变量引用了对象，并逃离方法的作用域，需要考虑线程安全
		5）栈内存溢出的情况：java.lang.StackOverflowError
			···栈帧过多
			···栈帧过大
		6）线程运行诊断：
			a、CPU利用率高
			···用top定位那个进程对cpu占用过高
			···ps H -eo pid,tid,%cpu | grep 进程id（用ps命令进一步定位那个线程引起的CPU占用过高)
			···jstack 进程id
				···通过线程id，找到相应的线程，并找到代码出问题的行数。
			b、java程序长时间没有输出结果（可能出现死锁）
			···jstack 进程id
	

	本地方法栈：为虚拟机使用到本地方法服务

<---线程共享的--->
	Java堆：存放对象实例（通过new关键字，创建对象都会使用堆内存）
		1）堆内存溢出（java.lang.OutOfMemoryError）
		2）堆内存诊断
			···jsp工具：查看当前系统中由哪些java进程
			···jmap工具：查看堆内存占用情况 jmap -heap 进程id
			···jconsole工具：图形界面，多功能的监测工具，可以连续监测。
		3）垃圾回收后，内存依然占用率很高
			···jvisualvm
		

	方法区：
		是各个线程共享的区域用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译的代码缓存等数据。（包括运行时常量池）
		反编译 .class javap -v *.class
		常量池：就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等。
		
		StringTable
		···常量池中的字符串仅是符号，第一次使用到时才变为对象
		···利用串池的机制，来避免重复创建字符串对象
		···字符串变量拼接原理是StringBuilder，并在java堆中
		···字符串常量拼接原理是编译期优化
		···可以使用intern方法，主动将串池中还没有的字符串对象放入串池。
			··· 将这个字符串对象尝试放入串池，如果有则不会放入，如果没有则放入串池，会把串池中的对象返回，并把原来的堆对象转移到常量池

2、直接内存：
	Native内存的引用存放在java堆里的DirectByteBuffer对象
	···常见于NIO操作时，用于数据缓存区
	···分配回收成本较高，但读写性能高
	···不受JVM内存回收管理
	···使用了Unsafe对象完成直接内存的分配回收，并且回收需要主动调用freeMemory()方法
	···ByteBuffer的实现类内部，使用了Cleaner(虚引用)来监测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，
	那么就会由RefernceHandler线程通过Cleaner的clean方法调用freeMemory来释放直接内存。
3、java堆中对象分配、布局和访问
	1）、对象创建
		指针碰撞  使用的java堆和空闲的java堆分离
		空闲链表  使用过的Java堆和空闲的java堆交叉存在
		

		内存分配完成之后，虚拟机必须将分配到的内存空间（不包括对象头）都初始化为零值。
	2）、对象布局
		对象在堆内存中的存储布局可以划分为：对象头、实例数据、对齐填充
		对象头：
			存储对象自身的运行时数据，哈希码、GC分带年龄、锁状态、线程持有的锁、偏向线程ID、偏向时间戳
			类型指针，指向它的类型元数据的指针
	3）、对象的访问定位(reference数据）
		句柄（用来标识对象或者项目的标识符）
		直接指针
	
		## 垃圾收集器与内存分配策略

1、如何判断对象“存活”
	1）引用计数算法：在对象中添加一个引用计数器，每当一个地方引用它，计数器值加一；当引用失效，计数器值减一；（Python语言）
	2）可达性分析算法：通过一系列被称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，
	搜索过程所走过的路径称为“引用链”，如果某个对象到GC Roots间没有任何引用链相连（从GC Roots到这个对象不可达），则证明对象是不可能在被使用（Java、C#）
	
2、引用
	1）强引用
	2）软引用（没有强引用，发生GC，内存依然紧张，就回收）
	3）弱引用（发生GC，就会回收）SoftRerence
	4）虚引用（处理直接内存，cleaner，引用队列）
	5）终结器引用--finalize方法

3、任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会再被执行。

4、“追踪式垃圾收集”
	1）分带收集理论：
		JAVA堆划分为新生代和老年代两个区域（在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。

5、垃圾回收算法
	1）标记清除算法
	···简单，速度快
	···易产生内存碎片
	2）标记整理
	···整理内存紧凑，大空间内存更多，无内存碎片
	···整理需要时间，开销较大，速度较慢
	3）标记复制
	···大小相等的两个内存（From、To）
		不会产生碎片、但是会占用双倍内存
6、分代垃圾回收机制
	新生代(Minor GC)：伊甸园、幸存区（From、To）
	老年代(Ful GC)
	1）对象首先分配在伊甸园区
	2）新生代空间不足，出发Minor GC，伊甸园和From存活的对象使用标记-Copy算法复制到To中，存活对象年龄加1，并且交换From和To
	3）minor gc 会引发Stop the world（STW），暂停其它用户的线程，垃圾回收结束后，用户线程才恢复运行。
	4）当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit）
	5）当老年代空间不足，会先尝试触发minor GC，如果之后空间仍然不足，那么出发Full GC，STW时间更长。如还不够触发 OutOfMemoryError
	
7、垃圾回收器
	1）串行（SerialGC）
	··· -XX:+UseSerialGC=Serial(新生代，复制算法) + SerialOld(老年代, 标记整理）
	···单线程，堆内存较小，适合个人电脑
	2）吞吐量优先（ParallelGC）
	··· -XX:+UseParallelGC   -XX:UseParallelOldGC  -XX:+UseAdaptiveSizePolicy(伊甸园和幸存区的大小自适应)  -XX:GCTimeRatio=ratio(垃圾回收时间占总时间) -XX:MaxGCPauseMillis=200ms
	···多线程，堆内存较大，多核cpu。单位时间内，STW的时间最短
	3）响应式优先（CMS）
	··· -XX:+UseConcMarkSweepGC  -XX:+UseParNewGC  ~ SerialOld
	···多线程，堆内存较大，多核cpu。单次STW尽可能的短

	4）、Garbage First（G1）
	将堆内存分为多个region区域
	三种阶段：
	···Young Collection
	···Young Collection + CM(并发标记，老年代占用堆空间的比例达到阈值) 45%
	···Mixed Collection(对E、S、O进行全面垃圾回收，最终标记，部分老年代拷贝复制---回收会使得内存容量最大化)
	Remark：写屏障，屏障队列

8、垃圾回收调优
	1）查看与垃圾回收相关的虚拟机参数:
		java -XX:PrintFlagsFinal -version | findstr "GC"
	2）新生代设置：-Xmn  set the initial and maximum size of the heap for young generation.
	
			类加载和字节码技术
1、java -cp ./lib/sa-jdi.jar sun.jvm.hotspot.HSDB
2、try-catch：利用Exception table
3、finally：将finally的指令复制3份，分别放入try流程，catch流程以及catch剩余的异常类型流程
4、语法糖
5、链接的步骤
	1）检查
	2）准备，为static变量分配内存（注意并没有完成赋值操作，但是final类型的基本类型和字符串在该阶段就已经完成赋值）
	3）解析：将常量池中的符号引用解析为直接引用
   初始化（懒惰的）
6、双亲委派类加载模式
	BootstrapClassLoader   ExtClassLoader  AppClassLoader

7、运行时优化（即时编译器JIT）
	逃逸分析、方法内联、字段优化


				内存模型（Java Memory Model， JMM）

1、多线程下保证队变量的安全访问
2、指令重排  （ volatile ）
3、CAS（compare and swap）乐观锁


​	

## 类文件结构

### Class类文件结构

* Class文件格式采用一种类似C语言结构体的伪结构来存储数据，这种伪结构只有两种数据类型：“无符号数”(u2: 表示2个字节的无符号数)和“表”(*_info)

  u4(magic)

  u2(minor_version)

  u2(major_version)

  u2(constant_pool_count)

  cp_info(constant_pool)

  u2(access_flags)

  u2(this_class)

  u2(super_class)

  u2(interface_count)

  u2(interfaces)

  u2(fields_count)

  field_info(fields)

  u2(meathods_count)

  methods_info(methods)

  u2(attributes_count)

  attributes_info(attributes)

* 魔数（magic）与Class文件的版本
  * magic ：确定这个文件是否为能被虚拟机接收的Class文件 0xCAFEBABE
  * minor_version: Class文件的次版本号
  * major_version: Class文件的主版本号
* 常量池
  * constant_pool_count：常量池容量计数值（索引0没有被用）
  * 常量池存放的两大类常量：
    * 字面量：文本字符串、被声明为final的常量值
    * 符号引用：各种描述符
* 访问标志（access_flags)
  * 识别类或接口层次的访问信息
* 类索引this_class
  * 该类的全限定名
* 父类索引super_class
  * 父类的全限定名
* 接口索引集合（interface_count、interfaces）
* 字段表集合（field_info)
  * 用于描述接口或者类中声明的变量
  * 类级变量（static）
  * 实例级变量
* 属性表集合attributes_info
  * Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息
  * Code属性、Exceptions属性、LineNumberTable属性、LocalVariableTable及LocalVariableTypeTable...

## 虚拟机类加载机制

### 类加载的时机

* 类加载到卸载的生命周期

  * 加载

  * 验证

  * 准备

  * 解析

  * 初始化

  * 使用

  * 卸载

    **其中验证、准备、解析**三个部分统称为**连接**

* 必须对类进行初始化的情况
  * 遇到new、getstatic、putstatic或invokestatic 字节码指令
    * 使用new关键字实例化对象的时候
    * 读取一个类的静态字段（被final修饰、已在编译期间把结果放入常量池的静态字段除外）
    * 调用一个类的静态方法
  * 使用java.lang.reflect包对类型进行反射调用的时候
  * 当初始化类的时候，发现其父类还没有初始化
  * 虚拟机启动，需要初始化主类（包含main()方法的类）
  * 动态语言支持（jdk7）：方法句柄对应的类没有被初始化
  * 接口中加入默认方法（jdk 8）
* 一个接口再初始化时，并不要求其父类全部接口都完成了初始化，只有在真正使用父类接口的时候才会初始化

​	

### 类的加载过程

**加载、验证、准备、解析和初始化**

* **加载**

  * 通过一个类的全限定名获取定义此类的二进制字节流
  * 将字节流所代表的静态存储结构转化为方法区的运行时数据结构
  * 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各个数据的访问入口

* **验证**（可以关闭）

  * 确保Class文件的字节流中包含的信息符合《java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全
  * 文件格式验证
  * 元数据验证
  * 字节码验证
  * 符号引用验证

* **准备**

  * 为类中定义的静态变量（static）分配内存并设置初始值，通常为0值  

    ```java
    public static int val = 123;  // 准备完成后，val的值是0，而不是123，赋值123的动作要到类的初始化阶段才会执行
    public static final int val = 123; // ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的值赋值123
    ```

  * 注意分配内存不包括实例变量，实例变量将会在对象初始化时，随着对象一起分配在java堆中

* **解析**

  * Java虚拟机将常量池内的符号引用替换为直接引用的过程

  * **符号引用**：以一组符号来描述锁引用的目标

  * **直接引用**： 可以直接指向目标的指针、相对偏移量或者能间接定位到目标的句柄

    ```java
    /**
     * 字段解析： 自身->接口->Parent(接口和继承的类的字段不能相同，除非子类覆盖）
     * 方法解析：自身->Parent->接口
     */
    ```

  * 对于接口，如果该接口的多个父接口中有多个简单名称和描述符都与目标相匹配的方法，将会从多个方法中返回一个。

* **初始化**

  * <clinit>() 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。
  * <clinit>() 方法和类的构造函数（<init>())不同，它不需要显示地调用父类构造器，Java虚拟机保证子类的<clinit>()方法，父类的<clinit>()方法已经执行完毕
  * 由于父类的<clinit>()方法先执行，所以父类定义的静态语句块要优先于子类的变量赋值操作。
  * 如果一个类中没有没有静态语句块，也没有对变量的赋值，那么编译器可以不为这个类生成<clinit>()方法。
  * 接口不能使用静态语句块，但仍有变量初始化赋值操作。执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法，因为只有当父接口中定义的变量被使用时，父接口才会初始化



### 类加载器

双亲委派模式





